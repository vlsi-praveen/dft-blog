<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Design Fundamentals | DFT Blog</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1><a href="index.html">ğŸ”§ DFT Blog</a></h1>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="01_Linux_Essentials.html">â† Prev</a>
                <a href="03_Verilog_for_DFT.html">Next â†’</a>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="article-header">
            <span class="article-number">Part 2 of 11</span>
            <h1>Digital Design Fundamentals</h1>
            <p class="subtitle">The foundation you need before diving into DFT</p>
            <p class="author">By <strong>Praveen Kumar Vagala</strong></p>
        </div>

        <h2>Combinational vs Sequential Logic</h2>
        <p>This is the most fundamental concept in digital design.</p>

        <h3>Combinational Logic</h3>
        <p><strong>No memory. Output depends only on current inputs.</strong></p>

<div class="diagram">        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Input â”€â”€â”‚   Logic   â”‚â”€â”€â–º Output
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
Output = f(current inputs)</div>

        <p>Examples: Adders, MUX, Decoders, ALU</p>

<pre><code>// 2:1 MUX - Pure combinational
module mux2to1 (
    input  a, b, sel,
    output y
);
    assign y = sel ? b : a;
endmodule</code></pre>

        <h3>Sequential Logic</h3>
        <p><strong>Has memory (flip-flops). Output depends on inputs AND previous state.</strong></p>

<div class="diagram">        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Input â”€â”€â”‚   Logic   â”‚â”€â”€â–º Output
        â”‚     â†‘     â”‚
        â”‚   [FF]    â”‚ â† Memory!
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
Output = f(inputs + stored state)</div>

        <p>Examples: Counters, FSMs, Registers, Shift Registers</p>

<pre><code>// Counter - Sequential (has memory)
module counter4 (
    input            clk, rst_n, en,
    output reg [3:0] count
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            count <= 4'b0;
        else if (en)
            count <= count + 1;
    end
endmodule</code></pre>

        <h2>Setup and Hold Time</h2>
        <p><strong>This is critical for DFT - most scan failures relate to timing!</strong></p>

        <h3>The Concept</h3>
<div class="diagram">Clock Period = 10ns

         ___________           ___________
CLK  ___|           |_________|           |___
        â†‘                     â†‘
     Rising Edge 1         Rising Edge 2
     
     |â† Tcq â†’|â† Combinational Logic â†’|â† Setup â†’|
              |â†â€•â€•â€•â€• Data Path â€•â€•â€•â€•â€•â€•â€•â€•â€•â†’|</div>

        <h3>Setup Time</h3>
        <p><strong>Data must be stable BEFORE the clock edge.</strong></p>
<div class="diagram">        Setup Time
        |â†â€•â€•â€•â€•â†’|
DATA  â”â”â”â”â”â”â”â”â”â”â”â”â”â•²
                    â•²â”â”â”â”â”â”
CLK   ________â”Œâ”€â”€â”€â”€â”€â”€â”________
              â†‘
         Clock Edge</div>

        <p><strong>Setup Violation:</strong> Data arrives too late â†’ FF captures wrong value.</p>

        <h3>Hold Time</h3>
        <p><strong>Data must stay stable AFTER the clock edge.</strong></p>
<div class="diagram">              |â†â€•â€•â†’|
              Hold Time
DATA  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•²
                       â•²â”â”â”
CLK   ________â”Œâ”€â”€â”€â”€â”€â”€â”________
              â†‘
         Clock Edge</div>

        <p><strong>Hold Violation:</strong> Data changes too fast â†’ FF captures garbage.</p>

        <h3>Timing Equations</h3>
<pre><code>Setup Check:
  Tclk_to_q + Tcomb + Tsetup < Clock_Period
  
Hold Check:  
  Tclk_to_q + Tcomb > Thold</code></pre>

        <h2>Metastability</h2>
        <p>When setup/hold is violated, the flip-flop enters an <strong>undefined state</strong>.</p>

<div class="diagram">Normal:     Input â†’ FF â†’ Clean 0 or 1

Metastable: Input â†’ FF â†’ ??? â†’ Eventually settles
                         â†‘
                   Unknown delay!
                   Could be 0 or 1!</div>

        <h3>Solution: Synchronizer</h3>
<div class="diagram">Async Input â†’ [FF1] â†’ [FF2] â†’ [FF3] â†’ Safe Output
              â†‘        â†‘        â†‘
              May be   Likely   Safe
              meta     stable</div>

        <p>Two or three flip-flops in series. Each stage reduces metastability probability exponentially.</p>

        <h2>Clock Domain Crossing (CDC)</h2>
        <p>When signals move between different clock domains:</p>

<div class="diagram">     CLK_A Domain              CLK_B Domain
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Logic   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   Logic   â”‚
    â”‚           â”‚  Danger!   â”‚           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘                        â†‘
        CLK_A                    CLK_B (different!)</div>

        <h3>Solutions</h3>
        <table>
            <tr><th>Method</th><th>Use Case</th></tr>
            <tr><td>2-FF Synchronizer</td><td>Single-bit signals</td></tr>
            <tr><td>Gray-coded FIFO</td><td>Multi-bit data</td></tr>
            <tr><td>Handshake Protocol</td><td>Control signals</td></tr>
            <tr><td>MUX Recirculation</td><td>Synchronized data</td></tr>
        </table>

        <h2>Finite State Machine (FSM)</h2>
        <p>Sequential circuits that move through defined states.</p>

<div class="diagram">         â”Œâ”€â”€â”€â”€â”€â”€â”  start  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  done  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”€â”€â”€â”€â–ºâ”‚ IDLE â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ RUNNING â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ FINISH â”‚
         â””â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
              â†‘                                  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>

        <h3>FSM Template</h3>
<pre><code>module fsm (
    input      clk, rst_n,
    input      start, done,
    output reg busy, complete
);
    // State encoding
    localparam IDLE    = 2'b00;
    localparam RUNNING = 2'b01;
    localparam FINISH  = 2'b10;
    
    reg [1:0] state, next_state;
    
    // State register (sequential)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic (combinational)
    always @(*) begin
        next_state = state;  // Default: stay
        case (state)
            IDLE:    if (start) next_state = RUNNING;
            RUNNING: if (done)  next_state = FINISH;
            FINISH:  next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign busy     = (state == RUNNING);
    assign complete = (state == FINISH);
endmodule</code></pre>

        <div class="summary">
            <h3>Key Takeaways</h3>
            <ol>
                <li><strong>Combinational:</strong> No memory, output = f(inputs)</li>
                <li><strong>Sequential:</strong> Has FFs, output = f(inputs + state)</li>
                <li><strong>Setup:</strong> Data stable BEFORE clock edge</li>
                <li><strong>Hold:</strong> Data stable AFTER clock edge</li>
                <li><strong>Metastability:</strong> Use synchronizers for async signals</li>
                <li><strong>CDC:</strong> Different clocks need special handling</li>
            </ol>
        </div>

        <div class="nav-buttons">
            <a href="01_Linux_Essentials.html" class="nav-btn prev">Linux Essentials</a>
            <a href="03_Verilog_for_DFT.html" class="nav-btn next">Verilog for DFT</a>
        </div>
    </div>
    
    <div class="footer">
        <p>DFT Engineering Blog Series | Part 2 of 11</p>
    </div>
</body>
</html>
